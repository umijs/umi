import { Message } from 'umi';

# Developing a Blog using Umi

This article will guide you through using Umi.js in conjunction with services and technologies like [PlanetScale](https://planetscale.com/), [Prisma](https://www.prisma.io/), and [Tailwindcss](https://tailwindcss.com/) to develop a simple blog website. You will learn how to deploy this website to [Vercel](https://vercel.com) hosting.

## Showcase

The end result will look like this: you will have a blog homepage displaying your articles at [https://umi-blog-example.vercel.app/](https://umi-blog-example.vercel.app/)

![Blog Homepage](https://img.alicdn.com/imgextra/i2/O1CN01a9YcgY24tEdndfXsw_!!6000000007448-2-tps-3104-1974.png)

Clicking on an article will take you to its full content: [https://umi-blog-example.vercel.app/posts/5](https://umi-blog-example.vercel.app/posts/5)

![Blog Article Page](https://img.alicdn.com/imgextra/i4/O1CN01k84YL21wHCpYx02Yc_!!6000000006282-2-tps-3104-1974.png)

You can also create new articles within the blog: [https://umi-blog-example.vercel.app/posts/create](https://umi-blog-example.vercel.app/posts/create)

![Create Article Page](https://img.alicdn.com/imgextra/i4/O1CN01DZkDt41jvt0BJMZqi_!!6000000004611-2-tps-3104-1974.png)

Assuming you are logged in: [https://umi-blog-example.vercel.app/login](https://umi-blog-example.vercel.app/login)

![Blog Login Page](https://img.alicdn.com/imgextra/i1/O1CN015ce0oY1uKkfMCa1vq_!!6000000006019-2-tps-3104-1974.png)

Ready? Let's begin!

## Environment Setup

First, ensure that your local environment is prepared for Umi.js project development. If you are new to Umi.js or haven't set up the development environment locally, I recommend reading the [Development Environment](../guides/prepare) tutorial.

Once your local environment is set up, you are ready to start working on the Umi.js project. Follow the steps in the [Boilerplate](../guides/boilerplate) document to quickly set up a Umi.js project.

### Adjusting the Directory Structure

Since our blog website will utilize Umi 4's API routing functionality, we need to make some adjustments to the directory structure generated by the boilerplate. Your current directory structure should look like this:

```
.
â”œâ”€â”€ assets
â”‚    â””â”€â”€ yay.jpg
â”œâ”€â”€ layouts
â”‚    â”œâ”€â”€ index.less
â”‚    â””â”€â”€ index.tsx
â”œâ”€â”€ node_modules
â”œâ”€â”€ package.json
â”œâ”€â”€ pages
â”‚    â”œâ”€â”€ docs.tsx
â”‚    â””â”€â”€ index.tsx
â”œâ”€â”€ pnpm-lock.yaml
â”œâ”€â”€ tsconfig.json
â””â”€â”€ typings.d.ts
```

We need to move the `assets`, `layouts`, and `pages` directories from the root directory to the `src` directory. After moving them, the structure should look like this:

```
.
â”œâ”€â”€ src 
â”‚   â”œâ”€â”€ assets
â”‚   â”‚    â””â”€â”€ yay.jpg
â”‚   â”œâ”€â”€ layouts
â”‚   â”‚    â”œâ”€â”€ index.less
â”‚   â”‚    â””â”€â”€ index.tsx
â”‚   â””â”€â”€â”€â”€ pages
â”‚        â”œâ”€â”€ docs.tsx
â”‚        â””â”€â”€ index.tsx
â”œâ”€â”€ node_modules
â”œâ”€â”€ package.json
â”œâ”€â”€ pnpm-lock.yaml
â”œâ”€â”€ tsconfig.json
â””â”€â”€ typings.d.ts
```

Adjusting the structure is necessary to avoid conflicts between the API route directory and the build output directory.

### Registering the PlanetScale Service

Our blog will store user and article data in a MySQL database. We will use the [PlanetScale](https://planetscale.com/) service to deploy a ready-to-use database without the need for a physical server.

To begin, log in to your account at [https://auth.planetscale.com/sign-in](https://auth.planetscale.com/sign-in). If you haven't registered, you can log in with GitHub or create an account by clicking [Sign up for an account](https://auth.planetscale.com/sign-up).

![PlanetScale Login](https://img.alicdn.com/imgextra/i4/O1CN01BVVAju1eONxEM9wr5_!!6000000003861-2-tps-2506-1464.png)

After logging in, create a database in your PlanetScale account. If you're registering for the first time, you'll receive step-by-step instructions to create a database.

![Create Database](https://img.alicdn.com/imgextra/i4/O1CN01St4IQW21lV6f8bpKg_!!6000000007025-2-tps-3104-1974.png)

Once the database is created, click the **Connect** button at the top right of the database page.

![Connect Button](https://img.alicdn.com/imgextra/i4/O1CN01Hnyqbo26g4UNnSqoQ_!!6000000007690-2-tps-3104-1974.png)

In the popup, select `Prisma` from the **Connect With** dropdown. You'll receive a connection string like this:

```dotenv
DATABASE_URL='mysql://************:************@************.ap-southeast-2.psdb.cloud/umi-blog-example?sslaccept=strict'
```

Save this connection string for later use.

### Installing Dependencies

Next, install the dependencies needed for this tutorial in your Umi project:

```shell
pnpm i -d prisma @types/bcryptjs @types/jsonwebtoken 
pnpm i @prisma/client bcryptjs jsonwebtoken
```

These commands install packages for:

1. [Prisma](https://www.prisma.io/) and [@prisma/client](https://www.npmjs.com/package/@prisma/client) to interact with the database.
2. [bcryptjs](https://github.com/dcodeIO/bcrypt.js) for secure password storage.
3. [jsonwebtoken](https://github.com/auth0/node-jsonwebtoken) for implementing user authentication.

Update the `package.json` `build` script to include `prisma generate`:

```json
"scripts": {
  "dev": "umi dev",
  "build": "prisma generate && umi build",
  "postinstall": "umi setup",
  "start": "npm run dev"
},
```

This ensures that Prisma client is generated before building the project.

### Installing Tailwindcss

Use Umi's generator to enable Tailwindcss in the project:

```shell
npx umi g tailwindcss
```

This command

 installs the necessary dependencies and generates required files for Tailwindcss.

### Initializing Page Components

When you use `pnpm dev` to start the project, you might encounter errors and startup failures. This is because we have declared some routes in the configuration, but we haven't created the corresponding page components yet!

Use Umi's generator to automatically create these pages: `login.tsx`, `posts/post.tsx`, `posts/create.tsx`:

```shell
npx umi g page login posts/post posts/create
```

The updated directory structure will look like this:

```
src
â”œâ”€â”€ assets
â”‚     â””â”€â”€ yay.jpg
â”œâ”€â”€ layouts
â”‚     â”œâ”€â”€ index.less
â”‚     â””â”€â”€ index.tsx
â””â”€â”€ pages
    â”œâ”€â”€ index.less
    â”œâ”€â”€ index.tsx
    â”œâ”€â”€ login.less
    â”œâ”€â”€ login.tsx
    â””â”€â”€ posts
        â”œâ”€â”€ create.less
        â”œâ”€â”€ create.tsx
        â”œâ”€â”€ post.less
        â””â”€â”€ post.tsx
```

Now, running `pnpm dev` should start the website without errors.

### Configuring the Umi Project

The final step is to configure the Umi project. For a complete configuration, refer to the [Configuration](../api/config) tutorial. For this tutorial, use the following configuration in `.umirc.ts`:

```ts
// .umirc.ts

export default {
  npmClient: 'pnpm',
  apiRoute: {
    platform: 'vercel'
  },
  routes: [
    { path: '/', component: 'index' },
    { path: '/posts/create', component: 'posts/create' },
    { path: '/login', component: 'login' },
    { path: '/posts/:postId', component: 'posts/post' },
  ],
  plugins: [require.resolve('@umijs/plugins/dist/tailwindcss')],
  tailwindcss: {}
};
```

In the configuration, `apiRoute` indicates that the project uses **API routes**, and `platform: 'vercel'` specifies deployment to [Vercel](https://vercel.com). This platform is targeted during `umi build` to package the API routes.

To successfully deploy to Vercel, add a `vercel.json` configuration file to the root directory:

```json
{
  "build": {
    "env": {
      "ENABLE_FILE_SYSTEM_API": "1"
    }
  },
  "rewrites": [
    {
      "source": "/api/:match*",
      "destination": "api/:match*"
    }
  ]
}
```

The `routes` configuration lists the website's routes, including the homepage, article creation, login, and individual article pages.

The `plugins` configuration indicates that the Umi Tailwindcss plugin is enabled, and the subsequent `tailwindcss` entry enables the plugin.

Now you have everything in place to start developing your Umi.js blog and deploying it to Vercel!

## API Route Design

Our entire blog website consists of two main parts: half of it is the front-end code running in the browser, and the other half is the server-side code running in Serverless Functions.

Why do we need to divide it into two parts? This is because there is some code that we cannot allow to run in the browser, such as user authentication, database integration, etc. These functionalities must be implemented as a service and exposed to the front-end as APIs. This part can be achieved through the API route feature of Umi 4.

> (Here, it seems like a diagram could provide a clearer explanation.)

Since we have already enabled the API route feature in the `.umirc.ts` configuration file, we can now directly add an `api` directory under the `src` directory. This directory provides API route development using convention-based routing.

> (Here, a diagram might help explain better.)

As a blog's API service, it's easy to imagine that we will need these endpoints for user interactions:

1. User Registration: `POST /api/register`
2. User Login: `POST /api/login`
3. Publish Article: `POST /api/posts`
4. Retrieve All Articles: `GET /api/posts`
5. Retrieve One Article: `GET /api/posts/{postId}`

So we can create these new files in the `src/api` directory:

```text
src
â”œâ”€â”€ api
â”‚     â”œâ”€â”€ login.ts
â”‚     â”œâ”€â”€ register.ts
â”‚     â””â”€â”€ posts
â”‚           â”œâ”€â”€ [postId].ts
â”‚           â””â”€â”€ index.ts
...
```

<Message emoji="ðŸ’¡">
You might have noticed that there is a file named `[postId].ts`. This notation means that this route can dynamically match different values. For example, both requests `/api/posts/1` and `/api/posts/2` will be handled by `src/api/posts/[postId].ts`, with `req.params` being `{ postId: 1 }` and `{ postId: 2 }` respectively.
</Message>

Each `.ts` file here represents an **API Handler**. They export a function by default to handle requests sent to that path. You can start by writing:

```ts
import type { UmiApiRequest, UmiApiResponse } from "umi";

export default async function (req: UmiApiRequest, res: UmiApiResponse) {
  res.status(400).json({ error: "This API is not implemented yet." })
}
```

Then, you can try accessing these API routes using a browser or [Postman](https://www.postman.com). For example, you can access `http://localhost:8000/api/login` to see the response data you just wrote ðŸŽ‰

![Not implemented yet](https://img.alicdn.com/imgextra/i3/O1CN01IRTlsd1HXmvCRJUt1_!!6000000000768-2-tps-1302-666.png)

We will come back later to implement the actual functionality of these API routes, as there's something more important to address.

## Define Schema

Now we need to determine a crucial aspect: what data do we want to store, how do we want to store it in the database, and in what format should we respond to the front end?

### Article Data

Each entry of article data represents an article within our blog. We can design it based on our system's needs. For example, our example includes these data:

- `id`: Article ID
- `title`: Article title
- `authorId`: Author's ID
- `tags`: Article tags (comma-separated)
- `imageUrl`: Link to the article's cover image
- `content`: Article content (in Markdown format)

### User Data

Each entry of user data represents a registered user on our blog. We can design it based on our system's needs. For example, our example includes these data:

- `id`: User ID
- `name`: Name
- `email`: Email
- `avatarUrl`: Link to the avatar
- `passwordHash`: Encrypted password

### Generating Configuration

> This section might benefit from referring to the official [Prisma documentation](https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-mysql)

Once we've defined the data format, we want Prisma to generate a corresponding client based on our Schema design. It should also automatically migrate the database to match our design.

#### Connect to the Database

First, in the root directory, create a `.env` file and add the connection information you obtained from the [PlanetScale registration](#registering-for-planetscale-service) section:

```dotenv
# .env

DATABASE_URL='mysql://************:************@************.ap-southeast-2.psdb.cloud/umi-blog-example?sslaccept=strict'
```

#### Write Prisma Configuration

Second, create a `prisma/schema.prisma` file in the root directory and define our Schema using [Prisma syntax](https://pris.ly/d/prisma-schema):

```prisma
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["referentialIntegrity"]
}

datasource db {
  provider = "mysql"
  referentialIntegrity = "prisma"
  url      = env("DATABASE_URL")
}

model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String   @db.VarChar(255)
  content   String?
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
  imageUrl  String?
  tags      String

  @@index(authorId)
}

model User {
  id            Int      @id @default(autoincrement())
  email         String   @unique
  passwordHash  String
  name          String?
  posts         Post[]
  avatarUrl     String?
}
```

After that, run the following command in the terminal:

```shell
npx prisma migrate dev --name init
```

This will migrate the MySQL database to match our defined format. Then, run:

```shell
npx prisma generate
```

This will generate a client package customized to our Schema design.

---

So far, we have successfully handled the database part. Next, we will focus on how to use the Prisma client package in our API routes to fetch and update data.

## Implementing API Routes

Now we will go back and implement the `.ts` files under the `api` directory that we created earlier. As long as we understand:

1. How the API will be called (path, request header, request body)
2. What we should do inside the API
3. What response content should be sent back (status, response header, response body)

Developing API routes is similar to writing simple functions.

### User Registration

When a user makes a `POST` request to `/api/register`, it means they want to register an account on our blog.

<Message>
You can find the source code for this example at [https://github.com/umijs/umi-blog-example/blob/main/src/api/register.ts](https://github.com/umijs/umi-blog-example/blob/main/src/api/register.ts)!
</Message>

```ts
// src/api/register.ts

import

 type { UmiApiRequest, UmiApiResponse } from "umi";
import { PrismaClient } from '@prisma/client'
import bcrypt from 'bcryptjs'
import { signToken } from "@/utils/jwt";

export default async function (req: UmiApiRequest, res: UmiApiResponse) {
  switch (req.method) {

    // If a POST request is made to this path, it means they want to register an account
    case 'POST':
      try {

        // Create a Prisma client to help us connect to the database
        const prisma = new PrismaClient();

        // Create a new entry in the User table in the database
        const user = await prisma.user.create({
          data: {
            email: req.body.email,

            // Password is encrypted using bcrypt
            passwordHash: bcrypt.hashSync(req.body.password, 8),
            name: req.body.name,
            avatarUrl: req.body.avatarUrl
          }
        });

        // Return the successfully created user data (without the password) and JWT token to the frontend
        res.status(201)
          .setCookie('token', await signToken(user.id))
          .json({ ...user, passwordHash: undefined })

        // Remember to disconnect from the database after handling the request
        await prisma.$disconnect();

      } catch (e: any) {

        // If an unexpected error occurs, provide the corresponding error code reference from the Prisma documentation to the user
        res.status(500).json({
          result: false,
          message: typeof e.code === 'string' ? 'https://www.prisma.io/docs/reference/api-reference/error-reference#' + e.code.toLowerCase() : e
        })
      }
      break;
    default:
      // If it's not a POST request, it means they are accessing this API incorrectly
      res.status(405).json({ error: 'Method not allowed' })
  }
}
```

After development, you can use Postman to send requests to this API and test if the functionality works as expected.

### User Login

When a user makes a `POST` request to `/api/login`, it means they want to log in to our blog and obtain a JWT token, which they can use to create new articles.

<Message>
This section is left for readers to practice. You can find the example source code at [https://github.com/umijs/umi-blog-example/blob/main/src/api/login.ts](https://github.com/umijs/umi-blog-example/blob/main/src/api/login.ts)!
</Message>

### Publish Article

When a user makes a `POST` request to `/api/posts`, it means they want to publish an article on our blog.

<Message>
This section is left for readers to practice. You can find the example source code at [https://github.com/umijs/umi-blog-example/blob/main/src/api/posts/index.ts](https://github.com/umijs/umi-blog-example/blob/main/src/api/posts/index.ts)!
</Message>

### Retrieve All Articles

When a user makes a `GET` request to `/api/posts`, it means they want to retrieve all article data.

<Message>
This section is left for readers to practice. You can find the example source code at [https://github.com/umijs/umi-blog-example/blob/main/src/api/posts/index.ts](https://github.com/umijs/umi-blog-example/blob/main/src/api/posts/index.ts)!
</Message>

### Retrieve One Article

When a user makes a `GET` request to `/api/posts/{postId}`, it means they want to retrieve data for a specific article.

<Message>
This section is left for readers to practice. You can find the example source code at [https://github.com/umijs/umi-blog-example/blob/main/src/api/posts/%5BpostId%5D.ts](https://github.com/umijs/umi-blog-example/blob/main/src/api/posts/%5BpostId%5D.ts)!
</Message>

## Implement Page Components

In this section, we will learn how to call APIs within page components to achieve interactions such as fetching articles or registering users:

```tsx
// pages/index.tsx

import React, { useEffect, useState } from 'react';
import { history } from "umi";

export default function HomePage() {
  const [posts, setPosts] = useState<any[]>();
  return (
    <div>
      {!posts && <p>Loading...</p>}
      {posts && <div>
        {posts.map(post => <div key={post.id}>
          <div onClick={() => history.push(`/posts/${post.id}`)}>
            <p>{post.title}</p>
          </div>
        </div>)}
      </div>}
    </div>
  );
}
```

You can see that we maintain a `posts` state in the homepage component. When `posts` is `undefined`, we assume that the data hasn't finished loading. So we add a `useEffect` to make a request to the API route after the component is mounted, to retrieve the list of articles:

```tsx
// pages/index.tsx

import React, { useEffect, useState } from 'react';
import { history } from "umi";

export default function HomePage() {
  const [posts, setPosts] = useState<any[]>();

  async function refresh() {
    try {
      const res = await fetch('/api/posts');
      if (res.status !== 200) {
        console.error(await res.text());
      }
      setPosts(await res.json());
    } catch (err) {
      console.error(err)
    }
  }

  useEffect(() => {
    refresh();
  }, []);

  return (
    <div>
      {!posts && <p>Loading...</p>}
      {posts && <div>
        {posts.map(post => <div key={post.id}>
          <div onClick={() => history.push(`/posts/${post.id}`)}>
            <p>{post.title}</p>
          </div>
        </div>)}
      </div>}
    </div>
  );
}
```

Now, if you visit this page, you should initially see "Loading..." and after a while, all article titles should be rendered.

![titles](https://img.alicdn.com/imgextra/i1/O1CN01n3CA371n0PlgkdEvQ_!!6000000005027-2-tps-3104-1974.png)

Finally, you can add some styles:

![titles-with-style](https://img.alicdn.com/imgextra/i1/O1CN01sfpTVd1IGDLK068gY_!!6000000000865-2-tps-3104-1974.png)

---

Other pages are left for readers to implement. You can incorporate your own ideas and design styles. The source code can be referred to at [https://github.com/umijs/umi-blog-example/blob/main/src/pages](https://github.com/umijs/umi-blog-example/blob/main/src/pages)

## Deployment

Finally, commit your project to a git service and then log in to [Vercel](https://vercel.com):

![Vercel](https://img.alicdn.com/imgextra/i2/O1CN01X7LqFx1LbEMYzLT3k_!!6000000001317-2-tps-2720-1710.png)

If your project is hosted on GitHub, it's recommended to choose GitHub login so that you can easily import

 your existing repository into Vercel:

![Vercel New Project](https://img.alicdn.com/imgextra/i1/O1CN014qIgle23G171pvX0V_!!6000000007227-2-tps-2720-1818.png)

After importing, Vercel will automatically detect that your project is built with the Umi.js framework and set up the necessary configurations. Just click **Deploy** to start the deployment process:

![Deploy](https://img.alicdn.com/imgextra/i3/O1CN013Ts04x1tqyv4VhzbW_!!6000000005954-2-tps-1468-1064.png)

After the deployment is complete, your blog is officially online and accessible!

However, you might notice that the API routes in the website are not working because they lack the required environment variables for connecting to the database. We need to configure these:

![Settings](https://img.alicdn.com/imgextra/i1/O1CN01OYPPB61G61IKR8chz_!!6000000000572-2-tps-2632-1934.png)

In the project settings page, there's a section where you can set environment variables:

![Env](https://img.alicdn.com/imgextra/i4/O1CN01nOLflV1I4lRMwsYHk_!!6000000000840-2-tps-2632-1934.png)

You can input environment variables like `DATABASE_URL`, `JWT_KEY`, and any others you used in your app.

![Redeploy](https://img.alicdn.com/imgextra/i3/O1CN013dlBGs2506aFTigki_!!6000000007463-2-tps-2644-1890.png)

After adding the environment variables, click **Redeploy** to deploy a new version with the updated variables. Now your blog should be fully functional and accessible online!